<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Magnetic World</title><link href="http://localhost:8000/" rel="alternate"></link><link href="http://localhost:8000/feeds/all.atom.xml" rel="self"></link><id>http://localhost:8000/</id><updated>2018-02-25T00:00:00+08:00</updated><subtitle>Embracing Growth Mindset</subtitle><entry><title>Padavan+frp 实现内网穿透</title><link href="http://localhost:8000/posts/2018/Feb/padavan-frp.html" rel="alternate"></link><published>2018-02-25T00:00:00+08:00</published><updated>2018-02-25T00:00:00+08:00</updated><author><name>Allen Shen</name></author><id>tag:localhost,2018-02-25:/posts/2018/Feb/padavan-frp.html</id><summary type="html">&lt;p&gt;近期出国做毕业设计，走之前我觉得可能会有访问校内资源的需求，因此想通过宿舍的路由器访问学校内网。本文比较了几种常用的实现内网穿透的方法，并记录了frp的配置过程及遇到的问题。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面：近期出国做毕业设计，走之前我觉得可能会有访问校内资源的需求，因此想通过宿舍的路由器访问学校内网。本文比较了几种常用的实现内网穿透的方法，并记录了 frp 的配置过程及遇到的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="table-of-contents"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1"&gt;1 问题背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2"&gt;2 技术选型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#21-ddns"&gt;2.1 DDNS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#22-ngrok"&gt;2.2 Ngrok&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#23-frp"&gt;2.3 frp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#3-frp"&gt;3 frp 服务端配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#31-frp"&gt;3.1 下载 frp 服务端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#32"&gt;3.2 具体配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#4-frp"&gt;4 frp 客户端配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#5"&gt;5 遇到的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#6"&gt;6 后记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#7-reference"&gt;7 Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1 问题背景&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;不在学校，最大的问题就是无法使用某些校内的资源。我们学校的毕业设计平台只能在校内网访问，不仅如此，学校购买的数据库在校外也无法使用。我第一个想到的是 VPN，然而查了一下，发现我们学校的 VPN 只供教职工使用 ……&lt;/p&gt;
&lt;p&gt;&lt;img align="center" alt="vpn unavailable" src="http://localhost:8000/posts/2018/Feb/vpn.png"&gt;&lt;/p&gt;
&lt;p&gt;看来官方渠道我是享受不到了。&lt;/p&gt;
&lt;p&gt;但是，论文是不可能花钱买的，这辈子都不会花钱买的，校外又用不了学校的数据库，上不了校内网，只能靠自力更生维持一下生活了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2 技术选型&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="21-ddns"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.1 DDNS&lt;/h3&gt;
&lt;p&gt;首先我想到的是 DDNS，这是我想到的最容易实现的一个方案了。&lt;/p&gt;
&lt;p&gt;现在大家用的公网 IP 基本都是动态分配的，只要定时将自己的某个域名解析为当前使用的 IP 就可以了。&lt;/p&gt;
&lt;p&gt;我现在的 magnetic.world 域名是放在 DNSPod 上解析的，而 DNSPod 提供了功能比较齐全的 API，操作起来也比较容易。这里有一个造好的轮子：&lt;a href="https://github.com/anrip/ArDNSPod"&gt;ArDNSPod&lt;/a&gt;，有兴趣的朋友可以尝试一下。&lt;/p&gt;
&lt;p&gt;这个方案的问题是：单纯的 DDNS 适合能分配到独立公网 IP 的家庭宽带使用，而学校的 IP 相对来说比较紧张，所以在实际操作中校园网还使用了 NAT 技术，而此时每个学生是没有自己的独立公网 IP 的，此时 DDNS 就不起作用了。&lt;/p&gt;
&lt;p&gt;在此基础上，可以再配合 NAT 穿透实现域名与某个特定联网设备的映射（即 NAT-DDNS），但是实现较为麻烦。现在市面上流行的解决方案 —— 花生壳就是采用这种技术，这里不再赘述。没有用花生壳的主要原因就是不想花钱，而免费服务又太不稳定。&lt;/p&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="22-ngrok"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.2 Ngrok&lt;/h3&gt;
&lt;p&gt;Ngrok 作为另一款常用的内网穿透工具，也可以满足我这次的需求。事实上，我之前连接宿舍里的树莓派时使用的就是 Ngrok。但是这次为什么没有用呢？因为官方编译好的版本只能使用官方的 ngrok.com 服务，而其免费服务并不尽如人意。&lt;/p&gt;
&lt;p&gt;如果有自己的服务器的话，自然是用自己的服务器比较舒服。然而如果想用自己的服务器，就必须将嵌入的官方证书换成自己的证书，所以要自己编译客户端和服务器端，比较麻烦。&lt;/p&gt;
&lt;p&gt;另一个问题是 Ngrok 1.x 是开源的，但是已经停止开发。而做出了重大改进的 2.x 却暂时没有开源。Ngrok 1.x 还存在许多&lt;a href="https://github.com/inconshreveable/ngrok#production-use"&gt;已知问题&lt;/a&gt;，这样的工具用起来我感觉不太放心。&lt;/p&gt;
&lt;p&gt;还有一个问题是 Ngrok 1.x 不支持 udp（2.x 没试过），对于想玩游戏的人来说显然不太友好。虽然我的需求里并没有玩游戏这一条，但是我还是更倾向于使用功能更完善的工具 —— 万一哪天用到了呢？&lt;/p&gt;
&lt;p&gt;总结一下我没有选择 Ngrok 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开源版本停止开发，闭源版本只能使用官方服务，限制较多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使是开源版本也需要自己编译才能使用自己的服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开源版本存在许多已知问题，并且不支持 udp&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="23-frp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.3 frp&lt;/h3&gt;
&lt;p&gt;最后我决定使用 frp 实现我的需求，它和 Ngrok 一样，都是 C-S 架构的反向代理。我为什么选择它呢？原因有以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码开源，有已编译好的各平台二进制包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有设置可以通过一个配置文件完成，无需手动编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以热加载配置文件，不需要重启服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非常容易部署，几乎可以说是开箱即用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不占用服务端 80 端口，不影响 Web 服务器工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 udp 转发，支持 ssh，可一次性映射多个端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有 Dashboard，方便查看工作状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内置多种插件，可实现 http 和 socks5 代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可实现 P2P 内网穿透，数据流量可以不经过服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;国人开发，有详细的&lt;a href="https://github.com/fatedier/frp/blob/master/README_zh.md"&gt;中文文档&lt;/a&gt;，其他功能可查阅文档&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确定使用 frp 后，就该进行具体的配置了。实际上 frp 的配置十分简单，只需要设置几个基本参数即可。以下是我的配置过程，供各位参考。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="3-frp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3 frp 服务端配置&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="31-frp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3.1 下载 frp 服务端&lt;/h3&gt;
&lt;p&gt;这里首先注意一点，frp 服务端和客户端版本要一致。因为根据作者的说法，目前的交互协议可能随时改变，不保证向后兼容，所以以后更新时也要同时升级服务端和客户端。我使用的是目前的最新版本 ——v0.16.0，以下的配置也仅供此版本参考。&lt;/p&gt;
&lt;p&gt;我用的是搬瓦工的 VPS，系统是 64 位 CentOS 7，ssh 登录上去以后，直接使用&lt;code&gt;wget&lt;/code&gt;或&lt;code&gt;curl&lt;/code&gt;下载作者编译好的二进制包即可。这里我下载的是 64 位 linux 版本：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget https://github.com/fatedier/frp/releases/download/v0.16.0/frp_0.16.0_linux_amd64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再用&lt;code&gt;tar&lt;/code&gt;解压之：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar xvzf frp_0.16.0_linux_amd64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入解压后的文件夹中，就可以看到 frp 的客户端&lt;code&gt;frpc&lt;/code&gt;和服务端&lt;code&gt;frps&lt;/code&gt;，以及它们的配置文件了，这里我直接使用&lt;code&gt;frps.ini&lt;/code&gt;这个配置文件。&lt;/p&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="32"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3.2 具体配置&lt;/h3&gt;
&lt;p&gt;有两个最基本的配置要先弄好：frp 配置文件中默认的工作端口为 7000，可以修改 bind_port 字段来更换端口；接下来设置 privilege_token 字段，用于身份验证，注意服务端和客户端的 token 必须相同。&lt;/p&gt;
&lt;p&gt;根据我的需求，我需要以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个 dashboard，用于监控 frp 的工作状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程访问路由器的设置页面，用于监控路由器的工作状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 http 或 socks5 代理，用于访问校内网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先是 dashboard。由于 frp 在服务端中已经集成了 dashboard，只需要在配置文件里添加&lt;code&gt;dashboard_port = 7500&lt;/code&gt;即可。启动服务端后就可以使用&lt;code&gt;http://[server_addr]:7500&lt;/code&gt;访问 dashboard 界面，用户名密码默认均为&lt;code&gt;admin&lt;/code&gt;，且可以通过&lt;code&gt;dashboard_user&lt;/code&gt;和&lt;code&gt;dashboard_pwd&lt;/code&gt;两个字段来修改用户名和密码。&lt;/p&gt;
&lt;p&gt;&lt;img align="center" alt="frp dashboard" src="http://localhost:8000/posts/2018/Feb/frp_dashboard.png"&gt;&lt;/p&gt;
&lt;p&gt;然后是远程访问路由器设置页面，实际上就是访问部署在内网的 Web 服务。这个功能也是很常用的，比如调试 Web 页面等场景都用得到。在 frp 中只需设置&lt;code&gt;vhost_http_port&lt;/code&gt;即可，如&lt;code&gt;vhost_http_port = 8080&lt;/code&gt;，然后启动服务端即可，接下来的设置在客户端完成。&lt;/p&gt;
&lt;p&gt;最后是用于访问校内网的代理，我这里选择了 http 代理，方便手机使用。这里的设置全部在客户端完成，接下来会提到。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="4-frp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4 frp 客户端配置&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;我使用的 Padavan 固件中集成了 frp，首次使用的时候需要先更新一下。由于我的路由器处于内网中，因此需要运行客户端。&lt;/p&gt;
&lt;p&gt;通过路由器的设置页面就可以方便地修改 frp 的启动参数。首先是服务器的 IP 地址，端口和 token，对应的字段分别是&lt;code&gt;server_addr&lt;/code&gt;，&lt;code&gt;server_port&lt;/code&gt;和&lt;code&gt;privilege_token&lt;/code&gt;，值与服务端相同。&lt;/p&gt;
&lt;p&gt;由于 dashboard 集成在服务端，因此客户端就不需要额外的设置了。
接下来是内网 Web 服务的设置，在配置文件的&lt;code&gt;[web]&lt;/code&gt;中有以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;privilege_mode&lt;/code&gt;：特权模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：可选&lt;code&gt;http&lt;/code&gt;或&lt;code&gt;https&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;local_ip&lt;/code&gt;：Web 服务的内网 ip 地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;local_port&lt;/code&gt;：Web 服务的内网端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;use_gzip&lt;/code&gt;：是否压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;custom_domains&lt;/code&gt;：映射后在外网访问时的域名，如果不设置的话就只能通过&lt;code&gt;http://[server_ip]:[vhost_http_port]&lt;/code&gt;访问服务。有自己的域名和服务器的话可以设置一条 A 或者 CNAME 记录到自己已有的 IP 地址 / 域名上，就可以改用&lt;code&gt;http://[server_domain]:[vhost_http_port]&lt;/code&gt;访问服务了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，只要设置好以后开启客户端，在连接到服务端后就可以通过访问&lt;code&gt;http://[server_addr]:8080&lt;/code&gt;即可访问路由器的设置页面了，同时可以通过查看服务端的日志文件&lt;code&gt;frps.log&lt;/code&gt;来获取当前的工作和连接情况。&lt;/p&gt;
&lt;p&gt;代理的设置较为简单，只需设置&lt;code&gt;type&lt;/code&gt;，&lt;code&gt;remote_port&lt;/code&gt;和&lt;code&gt;plugin&lt;/code&gt;三个字段即可。如果是 http 代理，那么&lt;code&gt;plugin&lt;/code&gt;设置为&lt;code&gt;http_proxy&lt;/code&gt;；如果是 socks5 代理，那么&lt;code&gt;plugin&lt;/code&gt;设置为&lt;code&gt;socks5&lt;/code&gt;即可。最后只需将浏览器的代理设置为&lt;code&gt;[server_ip]:[remote_port]&lt;/code&gt;即可通过客户端所在机器访问互联网，从而实现访问校内网的功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="5"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5 遇到的问题&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;由于我的服务器在国外，所以出现了一个小问题。一开始启动服务端和客户端后一直报错：&lt;code&gt;Accept new mux stream error: broken pipe&lt;/code&gt;，后来在网上搜索了一下，发现问题出在 frp 的服务端和客户端通信时，时间戳会被用于加密验证中，防止报文被劫持后被其他人利用，因此服务端所在机器和客户端所在机器的时间相差不能超过 15 分钟，否则会报错。修改了服务器的时区后，问题就解决了。当然也可以在配置文件中修改&lt;code&gt;authentication_timeout&lt;/code&gt;参数（默认为 900，即 15 分钟），如果修改为 0，则不会对时间戳进行校验。但是出于安全因素考虑，我感觉还是保持默认参数比较好吧。&lt;/p&gt;
&lt;p&gt;另一个需要注意的地方是 frp 需要配置的端口比较多，尤其是同时要用到大量的 frp 功能的时候。如果你的服务器上还有很多其他的服务的话，最好查一下端口，防止冲突。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="6"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6 后记&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;当我把 frp 弄完以后，我发现 frp 的玩法还是很多的。以代理为例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;客户端位置&lt;/th&gt;
&lt;th align="center"&gt;服务端位置&lt;/th&gt;
&lt;th align="center"&gt;应用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;校内&lt;/td&gt;
&lt;td align="center"&gt;校外&lt;/td&gt;
&lt;td align="center"&gt;下载论文、访问校内网站&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;国内&lt;/td&gt;
&lt;td align="center"&gt;国外&lt;/td&gt;
&lt;td align="center"&gt;在国外使用国内的音视频服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;国外&lt;/td&gt;
&lt;td align="center"&gt;国内&lt;/td&gt;
&lt;td align="center"&gt;你懂的，而且支持 udp 转发，可以玩游戏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除此之外，frp 还支持 p2p 内网穿透和简单的文件访问服务，两者结合起来，应该可以做一个 p2p 网盘，而且流量不经过服务器，不会影响服务器的其他服务。&lt;/p&gt;
&lt;p&gt;至于其他玩法，大家可以尽情探索～&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="7-reference"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;7 Reference&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://cloud.tencent.com/developer/article/1005974"&gt;NAT 穿透原理浅浅说（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hsk.oray.com/news/3888.html"&gt;五大 NAT 穿透方法，解决内网问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.openwrtdl.com/wordpress/ngrok%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"&gt;ngrok 交互流程及原理解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://xingtingyang.com/866.html"&gt;使用 ngrok+shadowsocks 穿透内网校外也能畅快看论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.hihuyang.com/?p=99"&gt;Ngrok 替代品：frp，支持 UDP 协议的反向代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.right.com.cn/forum/thread-191839-1-1.html"&gt;老毛子固件使用 frp 进行内网穿透&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fatedier/frp/blob/master/README_zh.md"&gt;frp 中文文档&lt;/a&gt;&lt;/p&gt;</content><category term="frp"></category><category term="Tools"></category></entry><entry><title>常用正则表达式总结</title><link href="http://localhost:8000/posts/2017/Feb/regex-summary.html" rel="alternate"></link><published>2017-02-23T00:00:00+08:00</published><updated>2017-02-23T00:00:00+08:00</updated><author><name>Allen Shen</name></author><id>tag:localhost,2017-02-23:/posts/2017/Feb/regex-summary.html</id><summary type="html">&lt;p&gt;看完了一本正则表达式的书，过了一段时间打算用的时候却发现很多东西都忘了，得从头看书查找用法，所以这个总结就当做是我的学习笔记吧。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面：看完了一本正则表达式的书，过了一段时间打算用的时候却发现很多东西都忘了，得从头看书查找用法，所以这个总结就当做是我的学习笔记吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="table-of-contents"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1"&gt;1 匹配单个字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2"&gt;2 匹配多个字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3"&gt;3 位置匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4"&gt;4 子表达式与回溯引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#5"&gt;5 前后查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#6"&gt;6 正则表达式里的条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1 匹配单个字符&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单个任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转义字符，用于搜索有特殊含义的字符（也叫元字符）本身，如&lt;code&gt;\\&lt;/code&gt;搜索字符&lt;code&gt;\&lt;/code&gt;，&lt;code&gt;\.&lt;/code&gt;搜索字符&lt;code&gt;.&lt;/code&gt;等，也用于使普通字符成为元字符，如&lt;code&gt;\r&lt;/code&gt;表示回车符，&lt;code&gt;\n&lt;/code&gt;表示换行符等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义一个集合，并匹配集合中列举的字符，如&lt;code&gt;[ab]&lt;/code&gt;表示匹配字符&lt;code&gt;a&lt;/code&gt;或&lt;code&gt;b&lt;/code&gt;。也可使用字符集合区间，如&lt;code&gt;[0-9A-Fa-f]&lt;/code&gt;可以匹配一位 16 进制数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取反匹配，如&lt;code&gt;[^0-9]&lt;/code&gt;匹配一个不是数字的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注 1：匹配特定字符类别的元字符见下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个数字字符，等价于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个非数字字符，等价于&lt;code&gt;[^0-9]&lt;/code&gt;，注意：元字符中同一个字母的大小写往往代表相反的含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个字母数字或下划线字符，等价于&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个非字母数字下划线字符，等价于&lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个空白字符，等价于&lt;code&gt;[\f\n\r\t\v]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何一个非空白字符，等价于&lt;code&gt;[^\f\n\r\t\v]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 16 进制匹配时需要加&lt;code&gt;\x&lt;/code&gt;前缀，如&lt;code&gt;\x0A&lt;/code&gt;对应 ASCII 码表中 10 代表的字符，即换行符&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 8 进制匹配时需要加&lt;code&gt;\0&lt;/code&gt;前缀，如&lt;code&gt;\011&lt;/code&gt;对应 ASCII 码表中 9 代表的字符，即制表符&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注 2：必要时还可以使用 POSIX 字符类简化正则表达式，具体用法可以自行搜索。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2 匹配多个字符&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个或多个字符，如&lt;code&gt;\d+&lt;/code&gt;匹配一个或多个数字字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配零个或多个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#124;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑或，匹配某几个指定的模式，如&lt;code&gt;19&amp;#124;20&amp;#124;21&lt;/code&gt;匹配 19 或 20 或 21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配零个或一个字符，如&lt;code&gt;https?:&lt;/code&gt;匹配&lt;code&gt;http:&lt;/code&gt;或&lt;code&gt;https:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设定重复匹配次数，如&lt;code&gt;\d{3}&lt;/code&gt;匹配三个连续的数字，&lt;code&gt;\d{2,4}&lt;/code&gt;匹配两个、三个或四个连续的数字，&lt;code&gt;\d{2,}&lt;/code&gt;匹配至少两个连续的数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注 3：&lt;code&gt;*&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;{n,}&lt;/code&gt;都是贪婪型元字符，它们在寻找匹配时会尽可能地靠近文本的末尾而不仅限于下一个匹配。要想避免这种情况的发生，可以使用懒惰型元字符，即在贪婪型元字符的后面加上&lt;code&gt;?&lt;/code&gt;后缀，如&lt;code&gt;*?&lt;/code&gt;，&lt;code&gt;+?&lt;/code&gt;和&lt;code&gt;{n,}?&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3 位置匹配&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个单词的开始或结尾。&lt;code&gt;\b&lt;/code&gt;实际上匹配的是一个能构成单词的字符和一个不能构成单词的字符之间的位置，如&lt;code&gt;\bhis\b&lt;/code&gt;仅匹配&lt;code&gt;his&lt;/code&gt;这个单词而不匹配&lt;code&gt;this&lt;/code&gt;这样包含&lt;code&gt;his&lt;/code&gt;三个字母的单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个非单词边界，即两个能构成单词的字符或两个不能构成单词的字符之间。如&lt;code&gt;\B_\B&lt;/code&gt;可以用来查找前后都有多余空格的下划线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字符串的开头。如&lt;code&gt;^cat&lt;/code&gt;只匹配文本前三个字母是&lt;code&gt;cat&lt;/code&gt;的情况，对于其他的&lt;code&gt;cat&lt;/code&gt;则不匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾。如&lt;code&gt;cat$&lt;/code&gt;只匹配文本最后三个字母为&lt;code&gt;cat&lt;/code&gt;的情况，对于其他的&lt;code&gt;cat&lt;/code&gt;则不匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?m)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;启用分行匹配模式，此时&lt;code&gt;^&lt;/code&gt;不仅匹配字符串开头，还匹配换行符后的开始位置；&lt;code&gt;$&lt;/code&gt;不仅匹配字符串结尾，还将匹配换行符后面的结束位置。如&lt;code&gt;(?m)^\s*//.*$&lt;/code&gt;可以匹配所有的单行注释内容（以&lt;code&gt;//&lt;/code&gt;开头）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="4"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4 子表达式与回溯引用&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义一个子表达式，可以将几个表达式组合起来当做一个独立元素来使用，如&lt;code&gt;(cat){2,}&lt;/code&gt;可以匹配&lt;code&gt;catcatcat&lt;/code&gt;这样的文本。如果不加括号直接使用&lt;code&gt;cat{2,}&lt;/code&gt;，则只能匹配&lt;code&gt;catttttt&lt;/code&gt;这样的文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义一个回溯引用，代表之前出现的第一个子表达式，这个用法类似于变量。如&lt;code&gt;&amp;lt;[Hh]([1-6])&amp;gt;.*?&amp;lt;/[Hh]\1&amp;gt;&lt;/code&gt;可以匹配一对标题标签 (H1-H6)，如果不使用回溯引用则无法检查标签首尾的配对情况（因为会匹配&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h2&amp;gt;&lt;/code&gt;这样的情况）。类似地，&lt;code&gt;\2&lt;/code&gt;代表之前出现的第二个子表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;与&lt;code&gt;\1&lt;/code&gt;含义相同，多用于替换中，但各语言的实现有差异，具体用到时再查。替换时将匹配的模式分为几个子表达式，然后使用回溯引用来表示并替换即可。如使用&lt;code&gt;(\w+[\w\.]*@[\w\.]+\.\w+)&lt;/code&gt;可以匹配一个电子邮件地址，再使用&lt;code&gt;&amp;lt;a href="mailto:$1"&amp;gt;$1&amp;lt;/a&amp;gt;&lt;/code&gt;替换为可点击的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="5"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5 前后查找&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?=)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用正向前查找指定一个必须匹配但不在结果中返回的模式，一般来说&lt;code&gt;?=&lt;/code&gt;要放在子表达式中，如&lt;code&gt;.+(?=:)&lt;/code&gt;可以用于在存放一些 URL 地址（&lt;code&gt;http:&lt;/code&gt;, &lt;code&gt;ftp:&lt;/code&gt; 及 &lt;code&gt;https:&lt;/code&gt; 等开头的地址）的文本中找出协议名（&lt;code&gt;http&lt;/code&gt;,&lt;code&gt;ftp&lt;/code&gt; 及 &lt;code&gt;https&lt;/code&gt;等）而不包含冒号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;=)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正向后查找，用法与正向前查找类似，并且可以与正向前查找结合使用。如&lt;code&gt;(?&amp;lt;=&amp;lt;[Pp]&amp;gt;).*(?=&amp;lt;/[Pp]&amp;gt;)&lt;/code&gt;可以匹配 HTML 文档中段落的内容而不包含&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;标签，一般也称这种匹配为只 “ 消费 ” 了段落文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?!)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;负向前查找，将向前查找不与给定模式相匹配的文本，类似于对正向前查找取非&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;!)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;负向后查找，将向后查找不与给定模式相匹配的文本，类似于对正向后查找取非。例如在包含价格（如&lt;code&gt;$30&lt;/code&gt;）和数量（如&lt;code&gt;30&lt;/code&gt;）的文本中，&lt;code&gt;\b(?&amp;lt;!\$)\d+\b&lt;/code&gt;可以只匹配数量而不匹配价格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class="mk-toclify" id="6"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6 正则表达式里的条件&lt;/h2&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;匹配模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?(back-reference)true-regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当括号中的&lt;code&gt;back-reference&lt;/code&gt;（回溯引用）存在时，执行&lt;code&gt;true-regex&lt;/code&gt;代表的子表达式。如&lt;code&gt;(&amp;lt;[Aa]\s+[^&amp;gt;]+&amp;gt;\s*)?&amp;lt;[Ii][Mm][Gg]\s+[^&amp;gt;]+&amp;gt;(?(1)\s*&amp;lt;/[Aa]&amp;gt;)&lt;/code&gt;匹配的是这样的模式：找出&lt;code&gt;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt;标签，且如果标签是一个链接，就把外面嵌套的&lt;code&gt;&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;标签也找出来。其中，在条件里，回溯引用编号&lt;code&gt;1&lt;/code&gt;不需要被转义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?(back-reference)true-regex|false-regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;与上面的表达式类似，只不过在回溯引用不存在时将执行&lt;code&gt;false-regex&lt;/code&gt;（类似于&lt;code&gt;if-else&lt;/code&gt;语句）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注 4：正则表达式还可以使用前后查找条件，即只在一个向前查找或向后查找操作取得成功的情况下才允许执行一个表达式的条件，只要把条件中的回溯引用编号替换为一个完整的前后查找表达式即可。例如美国的邮政编码有两种格式，一种是 ZIP 格式（如&lt;code&gt;12345&lt;/code&gt;），另一种格式是 ZIP+4 格式（如&lt;code&gt;12345-6789&lt;/code&gt;），其中只有 ZIP+4 必须用连字符分隔前五位数字和后四位数字，那么可以使用&lt;code&gt;\d{5}(?(?=-)-\d{4})&lt;/code&gt;来匹配。但实际中需要使用前后查找条件的场合不多，因为往往有更简单的实现方法。&lt;/p&gt;</content><category term="regex"></category><category term="Tools"></category></entry></feed>